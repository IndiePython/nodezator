<htsl>

<head>
  <title>Nodezator Manual | Defining a more comples viewer node</title>
</head>

<body>

<p><a href="index.htsl">Table of contents</a> &gt; Defining a more complex viewer node</p>


<h1>Defining a more complex viewer node</h1>

<p>As we have been stressing so far, Nodezator doesn't require any kind of style or specific syntax to define nodes. As long as you point nodezator to the callable you want to use with the <i>main_callable</i> variable, it will take care of turning it into a node for you. As we also discussed, the callable doesn't even need to be a function. It can be a method, a class, or even a lambda. As long as you provide a callable, Nodezator can turn it into a node.</p>

<p>Furthermore, because <a href="https://pygame.org">pygame</a> (the library used for Nodezator's GUI) allows you to define and execute your own loop, you can actually go as complex as you want. You have complete control. For instance, you can make your viewer node responsive to window resizing and allow the user to scroll the visualization shown with both the keyboard and by dragging the mouse. None of this is related or dependent on Nodezator, it is all due to pygame's versatility.</p>

<p>As an example, we'll compare 02 versions of the <a href="https://github.com/KennedyRichard/pillow_example_node_pack/blob/main/feedback/view_image/__main__.py">view_image</a> node from the <a href="https://github.com/KennedyRichard/pillow_example_node_pack">pillow example node pack</a>. The first version, when the repository was first uploaded, consists of a function that just displays the image centered on the screen, which is our main callable used for the node, and another support function which just serves to blit a checker pattern on the background for aesthetics. Here's the code:</p>

<python>
"""Facility for image visualization."""

### standard library import
from itertools import cycle


### third-party imports

## pygame

from pygame import QUIT, KEYUP, K_ESCAPE, Surface, Rect

from pygame.display import get_surface, update
from pygame.time    import Clock
from pygame.math    import Vector2
from pygame.event   import get as get_events
from pygame.image   import fromstring as image_from_string
from pygame.draw    import rect as draw_rect


## Pillow
from PIL.Image import Image



### get screen and its rect

screen      = get_surface()
screen_rect = screen.get_rect()

### get a vector for the center of the screen
screen_center = Vector2(screen_rect.center)

### instantiate background
background = Surface(screen.get_size()).convert()

### create a flag to determine whether we must draw a
### a checker pattern on the background (in case we didn't
### do so yet)
MUST_DRAW_CHECKER_PATTERN = [None]


def blit_checker_pattern(surf):
    """Blit checker pattern on surf with colors and rect."""
    ### define settings

    color_a = (235, 235, 235)
    color_b = (120, 120, 120)

    rect_width  = 40
    rect_height = 40

    ### retrieve a rect from the surf
    surf_rect = surf.get_rect()

    ### create a color cycler from the received colors
    next_color = cycle((color_a, color_b)).__next__

    ### create a rect with the provided dimensions, called
    ### unit rect, since it represents an unit or tile in
    ### the checker pattern
    unit_rect = Rect(0, 0, rect_width, rect_height)

    ### use the unit rect width and height as offset
    ### amounts in the x and y axes

    x_offset = rect_width
    y_offset = rect_height

    ### "walk" the surface while blitting the checker
    ### pattern until the surface the entire area of
    ### the surface is covered by the checker pattern

    while True:

        ## if the unit rect isn't touching the
        ## surface area, invert the x_offset,
        ## move it back using such new x_offset and
        ## move it down using the y_offset

        if not surf_rect.colliderect(unit_rect):
            x_offset = -x_offset
            unit_rect.move_ip(x_offset, y_offset)

        ## if even after the previous if block the
        ## unit rect still doesn't touch the surface
        ## area, break out of the while loop
        if not surf_rect.colliderect(unit_rect): break

        ## draw the rect
        draw_rect(surf, next_color(), unit_rect)

        ## move the unit rect in the x axis using the
        ## x_offset
        unit_rect.move_ip(x_offset, 0)


def view_image(image: Image):
    """Display image centered on screen.
    To stop displaying the image just press &lt;Escape&gt;.
    This will trigger the exit of the inner loop.
    """
    ### if check pattern wasn't draw yet on background,
    ### do so now

    if MUST_DRAW_CHECKER_PATTERN:

        blit_checker_pattern(background)
        MUST_DRAW_CHECKER_PATTERN.pop()

    ### obtain surface from pillow image

    mode = image.mode
    size = image.size
    data = image.tobytes()

    surf = image_from_string(data, size, mode)

    ### clean the screen
    screen.blit(background, (0, 0))

    ### get rect for image and center it on the screen

    rect        = surf.get_rect()
    rect.center = screen_center

    ### blit image center on the screen using the rect
    screen.blit(surf, rect)

    ### timing support

    clock = Clock()
    running = True

    ### start loop

    while running:

        clock.tick(30)

        for event in get_events():

            if event.type == QUIT: running = False

            elif event.type == KEYUP:
                if event.key == K_ESCAPE:
                    running = False

        ### update screen
        update()


view_image.dismiss_exec_time_tracking = True

main_callable = view_image
</python>

<p>However, such version <b>has limitations</b>. The loop doesn't react to window resizing, which means resizing the window will make the screen go blank (the correct response to window resizing should be redrawing the surfaces and in some cases repositioning objects before doing so). Also, if the image is larger than the screen, you won't be able to see what's beyond the screen.</p>

<p>From now on we'll be looking into the new version of the view_image node script. I divided the code into smaller sections to help convey the different roles of each section of the code. As you look into each excerpt I'll provide brief comments, since the code itself is already commented in detail.</p>

<p>Before you delve into the code, however, I'd like to point out that <b>there is no perfect or correct way of defining loops in pygame</b>. You can use functions or classes, but even when using classes there are different ways to do it. I could even have split the node script into different modules to make the separation between the different parts even more clear.</p>

<p>Do not stress over the details. The code to be presented is just what I thought was the best solution for what was needed. As long as you understand the purpose of the individual pieces you'll be able to come up with your own solutions. You are also always welcome to ask on <a href="https://indiepython.com/discord">discord</a> or <a href="https://github.com/IndiePython/nodezator/discussions">github discussions</a> every time you have questions.</p>

<p>First of all, we have the imports and the definition of constants. Note that, only for the sake of making things a bit more organized, I relocated the definition of the <i>blit_checker_pattern()</i> function (and all related import statements) to a local module called <i>utils.py</i>:</p>

<python>
"""Facility for image visualization."""


### third-party imports

## pygame

from pygame import (

              QUIT,

              KEYUP,

              K_ESCAPE,


              K_w, K_a, K_s, K_d,
              K_UP, K_LEFT, K_DOWN, K_RIGHT,
              K_HOME,

              MOUSEBUTTONUP,
              MOUSEBUTTONDOWN,
              MOUSEMOTION,

              Surface,

            )

from pygame.display import get_surface, update
from pygame.time    import Clock
from pygame.event   import get as get_events
from pygame.image   import fromstring as image_from_string

from pygame.key import get_pressed as get_pressed_keys


## Pillow
from PIL.Image import Image


### local import
from .utils import blit_checker_pattern


### get screen reference and a rect for it

SCREEN      = get_surface()
SCREEN_RECT = SCREEN.get_rect()

### define scrolling speeds in different 2D axes

X_SCROLLING_SPEED = 20
Y_SCROLLING_SPEED = 20

### obtain fps maintaining operation
maintain_fps = Clock().tick

### define the framerate
FPS = 30
</python>

<p>Then, we start defining a class. Yes, this time we'll use a class to hold all needed methods to manage our node and its loop, including the method we'll be using as the main callable for our viewer node.</p>

<python linenofrom="63">
### now here comes the first big change on our script:
###
### rather than using a single function as our main
### callable, we'll create a whole class to hold
### several methods, one of which we'll be using
### as the main callable for our node;
###
### why do we do that? Simply because we'll be dealing
### with a lot state (different objects, values and
### behaviours) and classes are a great tool for such job

class ImageViewer:
    """Manages the loop of the view_image() node."""

    def __init__(self):
        """Create support objects/flags."""

        ### create a scroll area so the image can be moved
        ### around
        self.scroll_area = SCREEN_RECT.inflate(-80, -80)

        ### instantiate background

        self.background = (
          Surface(SCREEN.get_size()).convert()
        )

        ### create flag to indicate whether the checker
        ### pattern must be drawn on the background;
        ###
        ### the first time the node is executed the
        ### checker pattern is draw on the background
        ### and then this flag is set to False; it will
        ### remain False for the lifetime of the node,
        ### that is, it is used only that time;
        ###
        ### it is actually optional: we could draw the
        ### checker pattern right away if we wanted; we
        ### just avoid doing so because though it happens
        ### practically in an instant, there's no telling
        ### whether other nodes will also perform setups
        ### that take time when the node pack is loaded
        ### and the sum of the time taken by all nodes
        ### might end up resulting in a non-trivial amount
        ### of time to load the node pack;
        ###
        ### maybe we are just being overly cautious,
        ### though;
        self.must_draw_checker_pattern = True
</python>

<p>We then define the methods for the keyboard mode, that is, for when we use the keyboard to move our image around.</p>

<python linenofrom="113">
    def keyboard_mode_event_handling(self):
        """Event handling for the keyboard mode."""

        for event in get_events():

            if event.type == QUIT:
                self.running = False

            elif event.type == MOUSEBUTTONDOWN:

                if event.button == 1:
                    self.enable_mouse_mode()

            elif event.type == KEYUP:

                if event.key == K_HOME:

                    self.image_rect.center = (
                      SCREEN_RECT.center
                    )

                elif event.key == K_ESCAPE:
                    self.running = False

    def keyboard_mode_key_state_handling(self):
        """Handle pressed keys for keyboard mode."""

        key_input = get_pressed_keys()

        ### calculate x movement

        ## calculate x movement if the "moves_horizontally"
        ## flag is set

        if self.moves_horizontally:

            ## check whether "go left" and "go right"
            ## buttons were pressed

            go_left = any(
              key_input[key] for key in (K_a, K_LEFT)
            )

            go_right = any(
              key_input[key] for key in (K_d, K_RIGHT)
            )

            ## assign amount of movement on x axis
            ## depending on whether "go left" and "go right"
            ## buttons were pressed

            if go_left and not go_right:
                dx = -1 * X_SCROLLING_SPEED

            elif go_right and not go_left:
                dx = 1 * X_SCROLLING_SPEED

            else: dx = 0

        ## if the "moves_horizontally" flag is not set,
        ## it means the image's width is smaller than
        ## the screen's width, so there's no need to
        ## move/scroll horizontally anyway, so the
        ## movement is 0
        else: dx = 0

        ### perform the same checks/calculations for
        ### the y axis

        if self.moves_vertically:

            go_up = any(
              key_input[key] for key in (K_w, K_UP)
            )

            go_down = any(
              key_input[key] for key in (K_s, K_DOWN)
            )

            if (

                 (go_up and go_down)
              or (not go_up and not go_down)

            ):
                dy = 0

            elif go_up and not go_down:
                dy = -1 * Y_SCROLLING_SPEED

            elif go_down and not go_up:
                dy = 1 * Y_SCROLLING_SPEED

        else: dy = 0

        ### if there is movement in the x or y
        ### axis, move the image
        if dx or dy: self.move_image(dx, dy)

</python>

<p>Then, we define the <i>move_image()</i> method, which we used to move the image regardless of the active mode.</p>

<python linenofrom="212">
    def move_image(self, dx, dy):
        """Move image in x and/or y axis.

        It performs extra checks/movement relative to
        a scroll area to ensure the image never leaves
        the screen completely.
        """

        image_rect  = self.image_rect
        scroll_area = self.scroll_area

        ### apply x movement if != 0

        if dx &lt; 0:

            if (
              (image_rect.right + dx)
              &lt; scroll_area.right
            ):
                image_rect.right = scroll_area.right

            else: image_rect.x += dx

        elif dx &gt; 0:

            if (
              (image_rect.left + dx)
              &gt; scroll_area.left
            ):
                image_rect.left = scroll_area.left

            else: image_rect.x += dx

        ### apply y movement if != 0

        if dy &lt; 0:

            if (
              (image_rect.bottom + dy)
              &lt; scroll_area.bottom
            ):
                image_rect.bottom = scroll_area.bottom

            else: image_rect.y += dy

        elif dy &gt; 0:

            if (
              (image_rect.top + dy)
              &gt; scroll_area.top
            ):
                image_rect.top = scroll_area.top

            else: image_rect.y += dy
</python>

<p>Then comes the methods for the mouse mode, that is, for when we use the mouse to move the image around.</p>

<python linenofrom="267">
    def mouse_mode_event_handling(self):
        """Event handling for the mouse mode."""

        for event in get_events():

            if event.type == QUIT:
                self.running = False

            elif event.type == MOUSEMOTION:
                self.move_according_to_mouse(*event.rel)

            elif event.type == MOUSEBUTTONUP:

                if event.button == 1:
                    self.enable_keyboard_mode()

            elif event.type == KEYUP:

                if event.key == K_ESCAPE:
                    self.running = False

    def move_according_to_mouse(self, dx, dy):
        """Support method for the mouse mode."""

        if not self.moves_horizontally:
            dx = 0

        if not self.moves_vertically:
            dy = 0

        self.move_image(dx, dy)

    def mouse_mode_key_state_handling(self):
        """Mouse mode doesn't handle key pressed state.

        So this method does nothing.
        """
</python>

<p>The <i>watch_window_size()</i> method is used on the loop to watch out for changes in the window (screen) size. When it is found that the screen changed size, it performs setups to ensure the objects are positioned and drawn correctly.</p>

<python linenofrom="305">
    def watch_window_size(self):
        """Perform setups if window was resized."""

        ### if the screen and the background have the
        ### same size, then no window resizing took place,
        ### so we exit the function right away

        if SCREEN.get_size() == self.background.get_size():
            return

        ### otherwise, we keep executing the function,
        ### performing the needed setups

        ## reference image surf and rect locally

        image_surf = self.image_surf
        image_rect = self.image_rect

        ## update the screen rect's size
        SCREEN_RECT.size = SCREEN.get_size()

        ## center the image on the screen
        image_rect.center = SCREEN_RECT.center

        ## update the moving flags

        self.moves_horizontally = (
          image_rect.width &gt; SCREEN_RECT.width
        )

        self.moves_vertically = (
          image_rect.height &gt; SCREEN_RECT.height
        )

        ## recreate the background and redraw the checker
        ## pattern on it

        self.background = (

          Surface(SCREEN.get_size()).convert()

        )

        blit_checker_pattern(self.background)

        ## draw the background on the screen
        SCREEN.blit(self.background, (0, 0))

        ## blit image on the screen using its rect
        SCREEN.blit(image_surf, image_rect)

        ## replace the scroll area
        self.scroll_area = SCREEN_RECT.inflate(-80, -80)
</python>

<p>We then have more support methods: to enable different modes, to start and manage the loop and to (re)draw the objects when the image is moved.</p>

<python linenofrom="359">
    def enable_keyboard_mode(self):
        """Set behaviours to move image with keyboard."""

        self.handle_events = (
          self.keyboard_mode_event_handling
        )

        self.handle_key_state = (
          self.keyboard_mode_key_state_handling
        )

    def enable_mouse_mode(self):
        """Set behaviours to move image with the mouse.

        That is, by dragging.
        """

        self.handle_events = (
          self.mouse_mode_event_handling
        )

        self.handle_key_state = (
          self.mouse_mode_key_state_handling
        )

    def draw(self):
        """If image moved, redraw."""

        ### if the image is in the same position,
        ### do nothing by returning early

        if (
          self.last_topleft == self.image_rect.topleft
        ): return

        ### otherwise store the current position and
        ### redraw background and image

        self.last_topleft = self.image_rect.topleft

        SCREEN.blit(self.background, (0, 0))

        SCREEN.blit(
                 self.image_surf, self.image_rect
               )

    def loop(self):
        """Start and keep a loop.

        The loop is only exited when the running flag
        is set to False.
        """

        self.running = True

        while self.running:

            ## maintain a constant fps
            maintain_fps(FPS)

            ## watch out for change in the window size,
            ## performing needed setups if such change
            ## happened
            self.watch_window_size()

            ## execute main operation of the loop,
            ## that is, input handling and drawing

            self.handle_events()
            self.handle_key_state()
            self.draw()

            ## finally update the screen with
            ## pygame.display.update()
            update()
</python>

<p>Finally we define the method we'll be using as our main callable: the <i>view_image()</i> method. Note that once the method is defined and still in the body of our class definition we set the <i>dismiss_exec_time_tracking</i> attribute on the method. Also note that after leaving the class definition we instantiate the ImageViewer class and assign the view_image method as the main_callable.</p>

<python linenofrom="435">
    ### the method below is the main callable we'll use
    ### for our node;
    ###
    ### that is, we'll instantiate the ImageViewer class
    ### and use this method from the instance as the
    ### main callable;
    ###
    ### don't worry about the "self" parameter, Nodezator
    ### is smart enough to ignore it (actually, the smart
    ### one is inspect.signature(), the responsible for
    ### such behaviour)

    def view_image(self, image: Image):
        """Display image on screen.

        To stop displaying the image just press &lt;Escape&gt;.
        This will trigger the exit of the inner loop.
        """
        ### enable keyboard mode
        self.enable_keyboard_mode()

        ### draw the checker pattern on the background if
        ### needed; this flag is only used once for the
        ### lifetime of this node (check the comment on
        ### the __init__ method about this flag)

        if self.must_draw_checker_pattern:

            ### draw the checker pattern on the background
            blit_checker_pattern(self.background)

            ### set flag to false
            self.must_draw_checker_pattern = False


        ### obtain surface from pillow image

        mode = image.mode
        size = image.size
        data = image.tobytes()

        surf = image_from_string(data, size, mode)

        ### draw the background on the screen
        SCREEN.blit(self.background, (0, 0))

        ### get rect for image and center it on the screen

        rect = surf.get_rect()

        rect.center = SCREEN_RECT.center

        ### update the moving flags;
        ###
        ### such flags just indicate whether moving the
        ### image makes sense horizontally and
        ### vertically, depending on whether the image
        ### is larger than the screen or not;
        ###
        ### for instance, if the screen is wider than
        ### the image, then there is no need to move
        ### the image horizontally, so the corresponding
        ### flag is set to false

        self.moves_horizontally = (
          rect.width &gt; SCREEN_RECT.width
        )

        self.moves_vertically = (
          rect.height &gt; SCREEN_RECT.height
        )

        ### store image surface and rect

        self.image_surf = surf
        self.image_rect = rect

        ### blit image on the screen using its rect
        SCREEN.blit(surf, rect)

        ### create attribute to track topleft position
        self.last_topleft = rect.topleft

        ### loop
        self.loop()

        ### remove image surf and rect references

        del self.image_surf
        del self.image_rect

    ### set attribute on view_image method so the
    ### execution time tracking is dismissed for this
    ### node;
    ###
    ### we need to do this here rather than after
    ### instantiating ImageViewer because after
    ### instantiating the class the view_image method
    ### doesn't allow new attributes to be set on it
    view_image.dismiss_exec_time_tracking = True


### finally, we just need to instantiate the ImageViewer
### and use the view_image method as the main callable;
###
### note that we also make it so the callable can be found in
### this module using its own name, that is, 'view_image';
###
### we do so because when the node layout is exported as a python
### script, its name is used to find the callable
main_callable = view_image = ImageViewer().view_image
</python>


<p>This new version of the node script, including the <i>utils.py</i> local module from where it imports the  <i>blit_checker_pattern()</i> function, has only <b>600 lines</b>. It is a small number of lines and yet with just that we defined a viewer tool that can display an image, move it around using the keyboard and mouse and reposition/redraw the image automatically when the window is resized.</p>

<p>Also note that in addition to referencing the main callable to be used in the <i>main_callable</i> variable, we also created a variable called <i>view_image</i> at the same time. As explained in the code comment, if we use this node in a .ndz file and we want to export the file as Python code, we must ensure the main callable can be found on the node script module <i>__main__.py</i> using its name (in this case, <i>view_image</i>). The first version using a function doesn't need this extra step because the <i>def</i> statement already stores the function in the module using its name.</p>

<p>Moreover, no syntax or api is ever enforced by Nodezator, it is all plain pygame and its power in action. Of all the 598 lines of code the only change required by Nodezator was to point out the main callable using the <i>main_callable</i> variable. We also set the <i>dismiss_exec_time_tracking</i> attribute on the view_image method, but even this is a very small change and optional.</p>

<p>I hope this example gave you a tiny glimpse of pygame's power to create real-time visualization tools that are easy to develop and maintain, combined with Nodezator to integrate all of this in a node editing interface.</p>


<p><a href="ch-defining-viewer-nodes.htsl">Previous chapter</a> |  <a href="index.htsl">Table of contents</a> | <a href="ch-nodes-variable-parameters-custom-outputs.htsl">Next chapter</a></p>

</body>

</htsl>
